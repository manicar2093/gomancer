package gormimpl

import (
	"fmt"
	"os"
	"path"

	"github.com/charmbracelet/log"
	"github.com/coditory/go-errors"
	. "github.com/dave/jennifer/jen"
	"github.com/jinzhu/inflection"
	"github.com/manicar2093/gomancer/deps"
	"github.com/manicar2093/gomancer/domain"
	"github.com/manicar2093/gomancer/parser"
	"github.com/manicar2093/gomancer/tags"
	"github.com/manicar2093/gomancer/types"
	"github.com/rjNemo/underscore"
)

type (
	generatorData struct {
		repositoryStructName string
		db                   string
		receiverStatement    Code
		receiverVar          string
		modelQualifier       Code
		constructorName      string
	}
	generatorType func(parser.GenerateModelInput, generatorData, deps.Container) Code
)

func GenerateRepository(input parser.GenerateModelInput, goDeps deps.Container, inCreation deps.Dependency) error {
	repositoryStructName := fmt.Sprintf("%sRepository", input.PascalCase)
	receiverVar := "c"
	data := generatorData{
		repositoryStructName: repositoryStructName,
		db:                   "db",
		receiverStatement:    Id(receiverVar).Op("*").Add(Id(repositoryStructName)),
		receiverVar:          receiverVar,
		modelQualifier:       Qual(goDeps.Internal.Models.Path, input.PascalCase),
		constructorName:      fmt.Sprintf("New%sRepository", input.PascalCase),
	}

	modelPackagePath := path.Join(
		string(domain.InternalPackagePath),
		input.PackageEntityName,
	)

	if err := os.MkdirAll(modelPackagePath, os.ModePerm); err != nil {
		return errors.Wrap(err, "failed to create model package path")
	}

	if err := doGenerateRepository(input, data, goDeps, modelPackagePath); err != nil {
		return errors.Wrap(err, "failed to generate repository")
	}
	if err := doGenerateRepositoryTest(input, data, goDeps, inCreation, modelPackagePath); err != nil {
		return errors.Wrap(err, "failed to generate repository test")
	}

	return nil
}

func doGenerateRepository(input parser.GenerateModelInput, generatorData generatorData, goDeps deps.Container, modelPackagePath string) error {
	log.Info("Generating gorm repository...")

	f := NewFile(inflection.Plural(input.LowerNoSpaceCase))
	f.PackageComment("// Code generated by gomancer")

	generators := []generatorType{
		generateRepoStruct,
		generateRepoConstructor,
		generateSaveMethod,
		generateGetByIdMethod,
		generatedGetAllPaginatedMethod,
		generatePartialUpdateFunction,
		generateDeleteByIdFunction,
	}

	underscore.Each(generators, func(generator generatorType) {
		f.Add(generator(input, generatorData, goDeps))
	})

	return f.Save(
		path.Join(
			modelPackagePath,
			"repository_gomancer.go",
		),
	)
}

func doGenerateRepositoryTest(input parser.GenerateModelInput, generatorData generatorData, goDeps deps.Container, inCreation deps.Dependency, modelPackagePath string) error {
	log.Info("Generating tests suite for package...")
	pluralEntityName := inflection.Plural(input.LowerNoSpaceCase)
	packageName := fmt.Sprintf("%s_test", pluralEntityName)
	suiteFile := NewFile(packageName)

	createImportStatement(suiteFile,
		goDeps.Std.Testing,
		goDeps.Project.Core.Connections,
		goDeps.Project.Pkg.TestFunc,
		goDeps.Ginkgo,
		goDeps.Gomega.Dependency,
	).
		Line().
		Line().
		Var().Id("dbConn").Id("*").Id(goDeps.Project.Core.Connections.Alias).Dot("ConnWrapper").
		Line().
		Line().
		Func().Id(fmt.Sprintf("Test%s", input.PascalCase)).Params(Id("t").Op("*").Id("testing").Dot("T")).Block(
		Id("dbConn").Op("=").Id(goDeps.Project.TestFunc.Alias).Dot("GetTestingGormDB").Call().
			Line().
			Id("RegisterFailHandler").Call(Id("Fail")).
			Line().
			Id("RunSpecs").Call(Id("t"), Lit(fmt.Sprintf("%s Suite", input.PascalCase))),
	)

	if err := suiteFile.Save(
		path.Join(
			modelPackagePath,
			fmt.Sprintf("%s_suite_test.go", pluralEntityName),
		)); err != nil {
		return err
	}

	log.Info("Generating gorm repository tests...")
	testFile := NewFile(packageName)
	testFile.PackageComment("// Code generated by gomancer")

	hasDecimal, hasOptional := containsOptionalOrDecimal(input, goDeps)
	testFileDeps := []deps.Dependency{
		goDeps.Std.Time,
		goDeps.Project.Internal.Models,
		inCreation,
		goDeps.Project.Pkg.Generators,
		goDeps.Project.Pkg.TestFunc,
		goDeps.GoFakeIt,
		goDeps.Goption,
		goDeps.Ginkgo,
		goDeps.Gomega.Dependency,
		goDeps.Gomega.GStruct,
	}
	if hasDecimal {
		testFileDeps = append(testFileDeps, goDeps.UDecimal)
	}
	if hasOptional {
		testFileDeps = append(testFileDeps, goDeps.Goption)
	}

	createImportStatement(
		testFile,
		testFileDeps...,
	).Line().
		Var().Id("_").Op("=").Id("Describe").
		Call(Lit("RepositoryGomancer"), Func().Params().Block(
			Var().Defs(
				Id("T").Op("=").Id("GinkgoT").Call(),
				Id("repo").Op("*").Id(pluralEntityName).Dot(generatorData.repositoryStructName),
			),

			Line(),
			Line(),

			Id("BeforeEach").Call(Func().Params().Block(
				Id("repo").
					Op("=").
					Id(pluralEntityName).
					Dot(generatorData.constructorName).
					Call(
						Id("dbConn"),
					),
			)),

			Line(),
			Line(),

			Id("Describe").Call(Lit("Save"), Func().Params().Block(
				Id("It").Call(Lit("should save"), Func().Params().Block(
					Id("item").Op(":=").Id(goDeps.Project.Pkg.Generators.Alias).Dot(fmt.Sprintf("Generate%s", input.PascalCase)).Call(Id("T"), Map(String()).Any().Block()),
					Line(),
					Line(),
					Id("Expect").Call(Id("repo").Dot("Save").Call(Op("&").Id("item"))).Dot("To").Call(Id("Success").Call()),
					Id("generators").Dot("FirstOrFail").Index(Id("models").Dot(input.PascalCase)).Call(Id("T"), Id("dbConn"), Lit("id = ?"), Id("item").Dot("Id")),
				)),
			)),

			Line(),
			Line(),

			Id("Describe").Call(Lit("GetById"), Func().Params().Block(
				Id("It").Call(Lit("should get by id"), Func().Params().Block(
					Id("item").Op(":=").Id(goDeps.Project.Pkg.Generators.Alias).Dot(fmt.Sprintf("Generate%s", input.PascalCase)).Call(Id("T"), Map(String()).Any().Block()),
					Id("generators").Dot("CreateOrFail").Call(Id("T"), Id("dbConn"), Op("&").Id("item")),
					Line(),
					List(Id("found"), Err()).Op(":=").Id("repo").Dot("GetById").Call(Id("item").Dot("Id")),
					Line(),
					Id("Expect").Call(Err()).Dot("ToNot").Call(Id("HaveOccurred").Call()),
					Id("Expect").Call(Op("*").Id("found")).Dot("To").Call(Id(goDeps.Gomega.GStruct.Alias).Dot("MatchFields").Call(Id(goDeps.Gomega.GStruct.Alias).Dot("IgnoreExtras"), Id(goDeps.Gomega.GStruct.Alias).Dot("Fields").Values(DictFunc(func(d Dict) {
						d[Lit(input.IdAttribute.PascalCase)] = Id("Equal").Call(Id("item").Dot("Id"))

						for _, attr := range input.Attributes {
							switch types.SupportedType(attr.Type) {
							case types.TypeDecimal:
								if attr.IsOptional {
									d[Lit(attr.PascalCase)] = Id("HaveField").Call(Id("testfunc").Dot("GetValueMethod"), Id("Equal").Call(Id("item").Dot(attr.PascalCase).Dot("GetValue").Call().Dot("RoundBank").Call(Lit(2))))
								} else {
									d[Lit(attr.PascalCase)] = Id("Equal").Call(Id("item").Dot(attr.PascalCase).Dot("RoundBank").Call(Lit(2)))
								}
							case types.TypeTime:
								if attr.IsOptional {
									d[Lit(attr.PascalCase)] = Id("HaveField").Call(Id("testfunc").Dot("GetValueMethod"), Id("BeTemporally").Call(Lit("~"), Id("item").Dot(attr.PascalCase).Dot("GetValue").Call()))
								} else {
									d[Lit(attr.PascalCase)] = Id("BeTemporally").Call(Lit("~"), Id("item").Dot(attr.PascalCase))
								}
							default:
								if attr.IsOptional {
									d[Lit(attr.PascalCase)] = Id("HaveField").Call(Id("testfunc").Dot("GetValueMethod"), Id("Equal").Call(Id("item").Dot(attr.PascalCase).Dot("GetValue").Call()))
								} else {
									d[Lit(attr.PascalCase)] = Id("Equal").Call(Id("item").Dot(attr.PascalCase))
								}
							}

						}
					})))),
				)),
			)),

			Line(),
			Line(),

			Id("Describe").Call(Lit("GetAllPaginated"), Func().Params().Block(
				Id("It").Call(Lit("should get all paginated"), Func().Params().Block(
					Var().Defs(
						Id("expectedPage").Op("=").Lit(1),
						Id("expectedSize").Op("=").Lit(10),
						Id("items").Op("=").Id("generators").Dot("Slice").Call(Func().Params().Id("models").Dot(input.PascalCase).Block(
							Return(
								Id("generators").Dot(fmt.Sprintf("Generate%s", input.PascalCase)).Call(Id("T"), Map(String()).Any().Values()),
							),
						), Id("expectedSize")),
					),
					Id("generators").Dot("CreateOrFail").Call(Id("T"), Id("dbConn"), Id("items")),
					Line(),
					Line(),
					List(Id("found"), Err()).Op(":=").Id("repo").Dot("GetAllPaginated").Call(Id("expectedPage"), Id("expectedSize")),
					Line(),
					Line(),
					Id("Expect").Call(Err()).Dot("ToNot").Call(Id("HaveOccurred").Call()),
					Id("Expect").Call(Int().Call(Id("found").Dot("CurrentPage"))).Dot("To").Call(Id("Equal").Call(Id("expectedPage"))),
					Id("Expect").Call(Int().Call(Id("found").Dot("PageSize"))).Dot("To").Call(Id("Equal").Call(Id("expectedSize"))),
					Id("Expect").Call(Id("found").Dot("Items")).Dot("To").Call(Id("HaveLen").Call(Id("expectedSize"))),
				)),
			)),

			Line(),
			Line(),

			Id("Describe").Call(Lit("PartialUpdateById"), Func().Params().Block(
				Id("It").Call(Lit("should partial update by id"), Func().Params().Block(
					Id("item").Op(":=").Id(goDeps.Project.Pkg.Generators.Alias).Dot(fmt.Sprintf("Generate%s", input.PascalCase)).Call(Id("T"), Map(String()).Any().Values()),
					Id("generators").Dot("CreateOrFail").Call(Id("T"), Id("dbConn"), Op("&").Id("item")),
					Line(),
					Line(),
					List(Id("updated"), Err()).Op(":=").Id("repo").Dot("PartialUpdateById").Call(Id("generators").Dot(fmt.Sprintf("Generate%sPartialUpdateById", input.PascalCase)).Call(Id("T"), Id("item").Dot("Id"), Map(String()).Any().Values())),
					Line(),
					Line(),
					Id("Expect").Call(Err()).Dot("ToNot").Call(Id("HaveOccurred").Call()),
					Id("Expect").Call(Op("*").Id("updated")).Dot("To").Call(Id(goDeps.Gomega.GStruct.Alias).Dot("MatchFields").Call(Id(goDeps.Gomega.GStruct.Alias).Dot("IgnoreExtras"), Id(goDeps.Gomega.GStruct.Alias).Dot("Fields").Values(DictFunc(func(d Dict) {
						d[Lit(input.IdAttribute.PascalCase)] = Id("Equal").Call(Id("item").Dot("Id"))

						for _, attr := range input.Attributes {
							switch types.SupportedType(attr.Type) {
							case types.TypeDecimal:
								if attr.IsOptional {
									d[Lit(attr.PascalCase)] = Id("HaveField").Call(Id("testfunc").Dot("GetValueMethod"), Id("Not").Call(Id("Equal").Call(Id("item").Dot(attr.PascalCase).Dot("GetValue").Call().Dot("RoundBank").Call(Lit(2)))))
								} else {
									d[Lit(attr.PascalCase)] = Id("Not").Call(Id("Equal").Call(Id("item").Dot(attr.PascalCase).Dot("RoundBank").Call(Lit(2))))
								}
							case types.TypeTime:
								if attr.IsOptional {
									d[Lit(attr.PascalCase)] = Id("HaveField").Call(Id("testfunc").Dot("GetValueMethod"), Id("Not").Call(Id("BeTemporally").Call(Lit("~"), Id("item").Dot(attr.PascalCase).Dot("GetValue").Call())))
								} else {
									d[Lit(attr.PascalCase)] = Id("Not").Call(Id("BeTemporally").Call(Lit("~"), Id("item").Dot(attr.PascalCase)))
								}
							default:
								if attr.IsOptional {
									d[Lit(attr.PascalCase)] = Id("HaveField").Call(Id("testfunc").Dot("GetValueMethod"), Id("Not").Call(Id("Equal").Call(Id("item").Dot(attr.PascalCase).Dot("GetValue").Call())))
								} else {
									d[Lit(attr.PascalCase)] = Id("Not").Call(Id("Equal").Call(Id("item").Dot(attr.PascalCase)))
								}
							}

						}
					})))),
				)),
			)),

			Line(),
			Line(),

			Id("Describe").Call(Lit("DeleteById"), Func().Params().Block(
				Id("It").Call(Lit("should delete by id"), Func().Params().Block(
					Id("item").Op(":=").Id(goDeps.Project.Pkg.Generators.Alias).Dot(fmt.Sprintf("Generate%s", input.PascalCase)).Call(Id("T"), Map(String()).Any()),
					Id("generators").Dot("CreateOrFail").Call(Id("T"), Id("dbConn"), Op("&").Id("item")),
					Line(),
					Line(),
					Err().Op(":=").Id("repo").Dot("DeleteById").Call(Id("item").Dot("Id")),
					Line(),
					Line(),
					Id("Expect").Call(Err()).Dot("ToNot").Call(Id("HaveOccurred").Call()),
					Id(goDeps.Project.Pkg.Generators.Alias).Dot("NotFoundOrFail").Index(Id(goDeps.Project.Internal.Models.Alias).Dot(input.PascalCase)).Call(Id("T"), Id("dbConn"), Lit("id = ?"), Id("item").Dot("Id")),
				)),
			)),
		))
	
	return testFile.Save(
		path.Join(
			modelPackagePath,
			"repository_gomancer_test.go",
		),
	)
}

func generateRepoStruct(_ parser.GenerateModelInput, generatorData generatorData, goDeps deps.Container) Code {
	return Type().Id(generatorData.repositoryStructName).Struct(
		Id(generatorData.db).Op("*").Qual(goDeps.Project.Core.Connections.Path, "ConnWrapper"),
	).Line().Line()
}

func generateRepoConstructor(input parser.GenerateModelInput, generatorData generatorData, goDeps deps.Container) Code {
	return Func().Id(generatorData.constructorName).Params(
		Id(generatorData.db).Op("*").Qual(goDeps.Project.Core.Connections.Path, "ConnWrapper"),
	).Op("*").Id(generatorData.repositoryStructName).Block(
		Return(
			Op("&").Id(generatorData.repositoryStructName).Values(
				Dict{
					Id(generatorData.db): Id(generatorData.db),
				},
			),
		),
	).Line().Line()
}

func generateSaveMethod(input parser.GenerateModelInput, generatorData generatorData, _ deps.Container) Code {
	return Comment("// Save can Create and Update an entity. You can use this for http PATH method. Check https://gorm.io/docs/update.html#Save-All-Fields for more info").
		Line().
		Func().Params(generatorData.receiverStatement).Id("Save").Params(
		Id("input").Op("*").Add(
			generatorData.modelQualifier),
	).Error().Block(
		If(
			Id("res").Op(":=").Id(generatorData.receiverVar).Dot(generatorData.db).Dot("Save").Call(
				Id("input"),
			),
			Id("res").Dot("Error").Op("!=").Nil(),
		).Block(
			Return(Id("res").Dot("Error")),
		),
		Return(Nil()),
	).Line().Line()
}

func generateGetByIdMethod(input parser.GenerateModelInput, generatorData generatorData, goDeps deps.Container) Code {
	return Func().Params(generatorData.receiverStatement).Id("GetById").Params(
		Id("id").Add(types.QualifiersByType(input.IdAttribute.Type, goDeps, input.IdAttribute.PascalCase, false)),
	).Params(
		Op("*").Add(generatorData.modelQualifier),
		Error(),
	).Block(
		Var().Id("found").Add(generatorData.modelQualifier),
		If(
			Id("res").Op(":=").Id(generatorData.receiverVar).Dot(generatorData.db).Dot("First").Call(
				Op("&").Id("found"),
				Id("id"),
			),
			Id("res").Dot("Error").Op("!=").Nil(),
		).Block(
			Return(Nil(), Id("res").Dot("Error")),
		),
		Return(Op("&").Id("found"), Nil()),
	).Line().Line()
}

func generatedGetAllPaginatedMethod(_ parser.GenerateModelInput, generatorData generatorData, goDeps deps.Container) Code {
	return Func().Params(generatorData.receiverStatement).Id("GetAllPaginated").Params(
		Id("pageNumber").Op(",").Id("pageSize").Int(),
	).Params(
		Op("*").Qual(goDeps.GormPager.Path, "Page").Index(generatorData.modelQualifier),
		Error(),
	).Block(
		Id("pager").Op(":=").Qual(goDeps.GormPager.Path, "Page").Index(generatorData.modelQualifier).Values(
			Id("PageSize").Op(":").Int64().Call(Id("pageSize")),
			Id("CurrentPage").Op(":").Int64().Call(Id("pageNumber")),
		),
		If(
			Id("err").Op(":=").Id("pager").Dot("SelectPages").Call(
				Id(generatorData.receiverVar).Dot(generatorData.db).Dot("GormPager"),
				Id(generatorData.receiverVar).Dot(generatorData.db).Dot("DB"),
			),
			Id("err").Op("!=").Nil(),
		).Block(
			Return(Nil(), Err()),
		),
		Return(Op("&").Id("pager"), Nil()),
	).Line().Line()
}

func generatePartialUpdateFunction(input parser.GenerateModelInput, generatorData generatorData, goDeps deps.Container) Code {
	return Type().
		Id("PartialUpdateByIdInput").
		StructFunc(func(g *Group) {
			g.
				Id(input.IdAttribute.PascalCase).
				Add(types.QualifiersByType(input.IdAttribute.Type, goDeps, input.IdAttribute.PascalCase, true)).
				Tag(
					tags.Tags(
						tags.NewJson(tags.JsonOptions{
							Name: input.IdAttribute.SnakeCase,
						}),
						tags.NewEcho(tags.EchoOptions{
							Name: input.IdAttribute.SnakeCase,
							Tag:  tags.EchoParam,
						}),
						tags.NewEcho(tags.EchoOptions{
							Name: input.IdAttribute.SnakeCase,
							Tag:  tags.EchoForm,
						}),
						tags.NewEcho(tags.EchoOptions{
							Name: input.IdAttribute.SnakeCase,
							Tag:  tags.EchoQuery,
						}),
						tags.NewValidate(
							underscore.Ternary[tags.ValidateGenerable](
								input.IdAttribute.Type == string(types.TypeUuid),
								tags.ValidateRequiredUuid{},
								tags.ValidateRequired{},
							),
						),
					),
				)
			underscore.Map(input.Attributes, func(item parser.Attribute) Code {
				return g.Id(item.PascalCase).Qual(domain.GoptionPkgPath, "Optional").Index(
					types.QualifiersByType(item.Type, goDeps, item.PascalCase, true),
				).Tag(
					tags.Tags(
						tags.NewJson(
							tags.JsonOptions{
								Name: item.SnakeCase,
							},
						),
						tags.NewEcho(tags.EchoOptions{
							Name: item.SnakeCase,
							Tag:  tags.EchoParam,
						}),
						tags.NewEcho(tags.EchoOptions{
							Name: item.SnakeCase,
							Tag:  tags.EchoForm,
						}),
						tags.NewEcho(tags.EchoOptions{
							Name: item.SnakeCase,
							Tag:  tags.EchoQuery,
						}),
					),
				)
			})
		}).
		Line().
		Line().
		Comment("PartialUpdateById can select which field has to be updated from given input").
		Line().
		Func().
		Params(generatorData.receiverStatement).
		Id("PartialUpdateById").
		Params(
			Id("changes").Id("PartialUpdateByIdInput"),
		).
		Params(
			Op("*").Add(generatorData.modelQualifier),
			Error(),
		).BlockFunc(
		func(g *Group) {
			g.Var().
				Defs(
					Id("result").
						Op("=").
						Add(
							generatorData.modelQualifier,
						).
						Values(),
					Id("updates").
						Op("=").
						Map(String()).
						Any().
						Values(),
				).
				Line()

			underscore.Each(input.Attributes, func(attribute parser.Attribute) {
				g.If(
					Id("changes").
						Dot(attribute.PascalCase).
						Dot("IsPresent").
						Call(),
				).Block(
					Id("updates").
						Index(Lit(attribute.SnakeCase)).
						Op("=").
						Id("changes").
						Dot(attribute.PascalCase).
						Dot("MustGet").
						Call(),
				)
			})

			g.
				Line().
				If(
					Id("len").
						Call(
							Qual("slices", "Collect").
								Call(
									Qual("maps", "Keys").
										Call(
											Id("updates"),
										),
								),
						).
						Op("==").
						Lit(0),
				).Block(
				If(
					Id("res").
						Op(":=").
						Id(generatorData.receiverVar).
						Dot(generatorData.db).
						Dot("First").
						Call(
							Op("&").Id("result"),
							Id("changes").Dot("Id"),
						),
					Id("res").
						Dot("Error").
						Op("!=").
						Nil(),
				).Block(
					Return(Nil(), Id("res").Dot("Error")),
				),

				Return(Id("&result"), Nil()),
			)

			g.
				Line().
				Line().
				If(
					Id("res").
						Op(":=").
						Id(generatorData.receiverVar).
						Dot(generatorData.db).
						Dot("Model").
						Call(Op("&").Id("result")).
						Dot("Clauses").
						Call(Qual(goDeps.Gorm.Clause.Path, "Returning").Values()).
						Dot("Where").
						Call(Lit("id = ?"), Id("changes").Dot("Id")).
						Dot("Updates").
						Call(Id("updates")),
					Id("res").Dot("Error").Op("!=").Nil(),
				).
				Block(
					Return(Nil(), Id("res").Dot("Error")),
				).
				Line().
				Line().
				Return(
					Op("&").Id("result"),
					Nil(),
				)
		},
	).
		Line().
		Line()

}

func generateDeleteByIdFunction(input parser.GenerateModelInput, generatorData generatorData, goDeps deps.Container) Code {
	return Func().
		Params(generatorData.receiverStatement).
		Id("DeleteById").
		Params(
			Id("id").
				Add(types.QualifiersByType(input.IdAttribute.Type, goDeps, input.IdAttribute.PascalCase, false)),
		).
		Error().
		Block(
			If(
				Id("res").
					Op(":=").
					Id(generatorData.receiverVar).
					Dot(generatorData.db).
					Dot("Delete").
					Call(
						Op("&").
							Add(generatorData.modelQualifier).
							Values(),
						Lit("id = ?"),
						Id("id"),
					),
				Id("res").
					Dot("Error").
					Op("!=").
					Nil(),
			).Block(
				Return(
					Id("res").Dot("Error"),
				),
			),
			Return(Nil()),
		)
}

func containsOptionalOrDecimal(input parser.GenerateModelInput, goDeps deps.Container) (bool, bool) {
	var hasDecimal, hasOptional bool

	for _, attribute := range input.Attributes {
		hasDecimal = types.SupportedType(attribute.Type) == types.TypeDecimal
		hasOptional = attribute.IsOptional

		if hasDecimal && hasOptional {
			break
		}
	}

	return hasDecimal, hasOptional
}

func createImportStatement(file *File, deps ...deps.Dependency) *Statement {
	var imported = Null().Line()
	for _, dep := range deps {
		imported.Id(dep.Alias).Lit(dep.Path).Line()
	}
	return file.Id("import").Parens(imported)
}
